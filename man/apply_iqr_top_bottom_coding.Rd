% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/apply_iqr_top_bottom_coding.R
\name{apply_iqr_top_bottom_coding}
\alias{apply_iqr_top_bottom_coding}
\title{Apply IQR-Based Top and Bottom Coding to LIS/LWS Variables}
\usage{
apply_iqr_top_bottom_coding(
  data_list,
  var_name,
  wgt_name = NULL,
  times = 3,
  one_sided = NULL,
  type = c("type_4", "type_2")
)
}
\arguments{
\item{data_list}{A named list of data frames, from LIS or LWS microdata.}

\item{var_name}{Character string. Name of the variable to code (e.g., "dhi").}

\item{wgt_name}{Optional character string. Name of the weight variable to use in computing weighted percentiles.}

\item{times}{Numeric. The IQR multiplier for determining bounds (default is 3).}

\item{one_sided}{Character. Set to \code{"top"}, \code{"bottom"}, or \code{NULL} for two-sided coding.}

\item{type}{Character. Type of quantile estimator to use (default is \code{"type_4"}).}
}
\value{
A list of data frames with the same structure as \code{data_list}, where \code{var_name}
has been adjusted by bounding extreme values according to an IQR rule.
}
\description{
This function performs top and/or bottom coding on a specified variable across a list of LIS/LWS datasets.
It applies an interquartile range (IQR)-based rule on the \code{log()} transformation of the variable.
Optionally, weights can be supplied, and the transformation can be one- or two-sided.
}
\details{
The function:
\itemize{
\item Transforms the variable to \code{log()} scale (logarithmic transformation).
\item Replaces invalid log-values (e.g. from log(0) or negatives) with zero.
\item Computes the IQR (interquartile range) on the log-transformed variable using weighted percentiles.
\item Caps values beyond \eqn{[Q1 - times * IQR, Q3 + times * IQR]} on the original scale using \code{exp()}.
}

Regarding LWS datasets:
\itemize{
\item Datasets with multiple imputations (via \code{inum}) are detected automatically.
\item Top and bottom coding is applied \strong{within each imputation group} in such datasets.
\item Datasets without \code{inum}, or with only a single imputation, are processed normally.
}

A warning is issued if the variable level (e.g. household vs individual) seems inconsistent with the dataset structure.
}
\examples{
\dontrun{ 
# Import data, ideally at the level of the variable of interest.
data_hhd <- lissyrtools::lissyuse("au", vars = c("dhi"), from = 2016)

# Default case, where top and bottom coding is performed simultaneously
data_hhd[1]  \%>\%
 purrr::map(~ .x[!is.na(.x$dhi), ]) \%>\%
 purrr::map(~ .x \%>\% mutate(new_wgt = nhhmem * hwgt)) \%>\%
 apply_iqr_top_bottom_coding("dhi", "hwgt", times = 3)

# Example with the use or arguments `one_sided` = {"top", "bottom"} and `type`
data_hhd[1]  \%>\%
 purrr::map(~ .x[!is.na(.x$dhi), ]) \%>\%
 purrr::map(~ .x \%>\% mutate(new_wgt = nhhmem * hwgt)) \%>\%
 apply_iqr_top_bottom_coding("dhi", "hwgt", one_sided = "top", type = "type_2") 

# Load individual-level datasets by selecting individual-level variables, if the target variable is at the individual level (e.g., "pilabour")
data_ind <- lissyrtools::lissyuse("au", vars = c("dhi", "pilabour"), from = 2016)

data_ind[1]  \%>\%
 purrr::map(~ .x[!is.na(.x$pilabour), ]) \%>\%
 apply_iqr_top_bottom_coding("pilabour", "ppopwgt")
}
}
